# coding: utf-8

"""
    ESMF

    A simple API to interact with the Edge Slice Management Function. Supports creating and removing slices across domains. Synchronises itself with other ESMFs to achieve a common goal. Please refer to the topology drawings for further information about the network structures.  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from esmf_client import schemas  # noqa: F401


class DomainConfiguration(
    schemas.DictSchema
):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.

    The configuration for this service
    """


    class MetaOapg:
        
        class properties:
            
            
            class type(
                schemas.EnumBase,
                schemas.StrSchema
            ):
                
                @schemas.classproperty
                def ESMF(cls):
                    return cls("ESMF")
                
                @schemas.classproperty
                def CTMF(cls):
                    return cls("CTMF")
            network = schemas.StrSchema
            
            
            class vpn_gateways(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    @staticmethod
                    def items() -> typing.Type['DeviceConfiguration']:
                        return DeviceConfiguration
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple['DeviceConfiguration'], typing.List['DeviceConfiguration']],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'vpn_gateways':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> 'DeviceConfiguration':
                    return super().__getitem__(i)
            
            
            class networks(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    @staticmethod
                    def items() -> typing.Type['NetworkConfiguration']:
                        return NetworkConfiguration
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple['NetworkConfiguration'], typing.List['NetworkConfiguration']],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'networks':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> 'NetworkConfiguration':
                    return super().__getitem__(i)
            
            
            class coordinators(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    @staticmethod
                    def items() -> typing.Type['DeviceConfiguration']:
                        return DeviceConfiguration
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple['DeviceConfiguration'], typing.List['DeviceConfiguration']],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'coordinators':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> 'DeviceConfiguration':
                    return super().__getitem__(i)
        
            @staticmethod
            def domain_controller() -> typing.Type['DeviceConfiguration']:
                return DeviceConfiguration
            reservable_bitrate = schemas.IntSchema
            __annotations__ = {
                "type": type,
                "network": network,
                "vpn_gateways": vpn_gateways,
                "networks": networks,
                "coordinators": coordinators,
                "domain_controller": domain_controller,
                "reservable_bitrate": reservable_bitrate,
            }
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["network"]) -> MetaOapg.properties.network: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["vpn_gateways"]) -> MetaOapg.properties.vpn_gateways: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["networks"]) -> MetaOapg.properties.networks: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["coordinators"]) -> MetaOapg.properties.coordinators: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["domain_controller"]) -> 'DeviceConfiguration': ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["reservable_bitrate"]) -> MetaOapg.properties.reservable_bitrate: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["type", "network", "vpn_gateways", "networks", "coordinators", "domain_controller", "reservable_bitrate", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> typing.Union[MetaOapg.properties.type, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["network"]) -> typing.Union[MetaOapg.properties.network, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["vpn_gateways"]) -> typing.Union[MetaOapg.properties.vpn_gateways, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["networks"]) -> typing.Union[MetaOapg.properties.networks, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["coordinators"]) -> typing.Union[MetaOapg.properties.coordinators, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["domain_controller"]) -> typing.Union['DeviceConfiguration', schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["reservable_bitrate"]) -> typing.Union[MetaOapg.properties.reservable_bitrate, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["type", "network", "vpn_gateways", "networks", "coordinators", "domain_controller", "reservable_bitrate", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *_args: typing.Union[dict, frozendict.frozendict, ],
        type: typing.Union[MetaOapg.properties.type, str, schemas.Unset] = schemas.unset,
        network: typing.Union[MetaOapg.properties.network, str, schemas.Unset] = schemas.unset,
        vpn_gateways: typing.Union[MetaOapg.properties.vpn_gateways, list, tuple, schemas.Unset] = schemas.unset,
        networks: typing.Union[MetaOapg.properties.networks, list, tuple, schemas.Unset] = schemas.unset,
        coordinators: typing.Union[MetaOapg.properties.coordinators, list, tuple, schemas.Unset] = schemas.unset,
        domain_controller: typing.Union['DeviceConfiguration', schemas.Unset] = schemas.unset,
        reservable_bitrate: typing.Union[MetaOapg.properties.reservable_bitrate, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'DomainConfiguration':
        return super().__new__(
            cls,
            *_args,
            type=type,
            network=network,
            vpn_gateways=vpn_gateways,
            networks=networks,
            coordinators=coordinators,
            domain_controller=domain_controller,
            reservable_bitrate=reservable_bitrate,
            _configuration=_configuration,
            **kwargs,
        )

from esmf_client.model.device_configuration import DeviceConfiguration
from esmf_client.model.network_configuration import NetworkConfiguration
