\documentclass{book}
\usepackage{graphicx} % Required for inserting images
\usepackage[T1]{fontenc}
\usepackage[final]{microtype}
\usepackage[hidelinks]{hyperref}
\emergencystretch=1em

\usepackage{enumitem, hyperref}
\makeatletter
\def\namedlabel#1#2{\begingroup
    #2%
    \def\@currentlabel{#2}%
    \phantomsection\label{#1}\endgroup
}
\makeatother

\usepackage{biblatex}
\addbibresource{background.bib}
\addbibresource{related_work.bib}
\addbibresource{methodology.bib}

\title{Thesis}
\author{Fritz Windisch}
\date{September 2023}

\begin{document}

\maketitle

\tableofcontents

\chapter{Introduction}
\begin{itemize}
    \item Motivation
    \item Objective
    \item Structure
\end{itemize}

\chapter{Background}
\iffalse
\begin{itemize}
    \item Domain
    \begin{itemize}
        \item Network Security
        % Source: netsec: Network Secutity Basics: https://ieeexplore.ieee.org/abstract/document/1556540
        % Source: honeypot: Honeypot in network security: a survey: https://dl.acm.org/doi/abs/10.1145/1947940.1948065
        % Source: cryptography: Importance of Cryptography in Network Security: https://ieeexplore.ieee.org/abstract/document/6524439
        % Source: games: Bridging Game Theory and Cryptography: Recent Results and Future Directions: https://link.springer.com/chapter/10.1007/978-3-540-78524-8_15
        % Source: goals: An Ontology for Network Security Attacks: https://link.springer.com/chapter/10.1007/978-3-540-30176-9_41
        \item Edge-Computing
        % Source: edgecomputing: The promise of edge computing: https://ieeexplore.ieee.org/abstract/document/7469991
    \end{itemize}
    \item Enabling technologies
    \begin{itemize}
        \item SDN
        % Source: sdn: SDN survey: https://www.sciencedirect.com/science/article/abs/pii/S1084804516300297
        % Source: openflow: OpenFlow Switch Specification: https://opennetworking.org/wp-content/uploads/2014/10/openflow-switch-v1.5.1.pdf
        \item NFV
        % Source: nfv: NFV survey: https://www.sciencedirect.com/science/article/abs/pii/S1389128618300306
        \item SFC
        % Source: sfc: SFC survey: https://www.sciencedirect.com/science/article/abs/pii/S1084804516301989
        % Source: rfc7665: Service Function Chaining (SFC) Architecture: https://datatracker.ietf.org/doc/html/rfc7665
        \item VPN
        % Source: vpn: https://link.springer.com/article/10.1023/B:PNET.0000026887.35638.ce
        % Source: wireguard: https://www.wireguard.com/papers/wireguard.pdf
        % Source: openvpn: https://openvpn.net/images/pdf/OpenVPN_WhitepaperJuly2010.pdf
        \item MPLS
        % Source: rfc3031: RFC: https://datatracker.ietf.org/doc/html/rfc3031
        \item 2PCP
        % Source: 2pcp: https://dl.acm.org/doi/10.1145/850770.850772
    \end{itemize}
    \item Concepts
    \begin{itemize}
        \item QoS
        % Source: qos: A QoS architecture: https://dl.acm.org/doi/10.1145/185595.185648 (includes loss rate, throughput, jitter, delay within flows)
        % serv: IntServ and DiffServ: https://ieeexplore.ieee.org/abstract/document/891025
        % rfc791 (IP Protocol), rfc1633 (IntServ), rfc2474 (DiffServ)
        \item Network Slicing
        % Source: slicing: Overview of network slicing in the 5G context: https://ieeexplore.ieee.org/abstract/document/8685766
    \end{itemize}
\end{itemize}
\fi
In this chapter we will establish some common terms concerning the technical background of this thesis. First we will describe our domain of network security and edge computing, before introducing key technologies that have been used such as software defined networks (SDN), network function virtualization (NFV), service function chaining (SFC), virtual private networks (VPN) and multi protocol label switching (MPLS). Lastly we will focus on concepts like quality of service (QoS) and network slicing.

\section{Domain}
\subsection{Network Security}
According to \cite{netsec}, network security can be viewed as a subset of computer security, focusing on network-perimeter and computer system security. Some means to achieve this include, but are not limited to, computer intrusion detection, traffic analysis and network monitoring. Computer intrusion detection can be realised by installing intrusion detection software on systems that should be protected or by deploying honeypots \cite{honeypot}. Honeypots are systems that are supposed to be targeted by attackers in order to detect and distract them. By using honeypots one can learn what the attacker is going to try and ideally deploy protective measures before the attacker reaches a real system that needs to be protected. Traffic analysis on the other hand can be used to detect attacks based on traffic shapes that are unusual compared to normal operation. The same applies to network monitoring which instead focuses on events in the network.

Another view on network security can be from the cryptographical standpoint \cite{netsec}. Cryptography plays a key role in network security, because it can be used to achieve four of the major goals of security in network contexts: confidentiality, integrity, authentication and non-repudiation \cite{cryptography}. In this context often times security games are played to define what an attacker may know or not know at a certain point of a secure protocol, e.g. a key exchange, and what the attacker can possibly guess \cite{games}. The assumption generally is, that while some parties are honest and behaving according to protocol, some malicious actors will participate in the protocol. These malicious actors should (hopefully) never reach their goal concerning the protection goals from above.

So while the two views presented so far are of different nature, what combines them is the set of major protection goals on a network. Here are some of the most noteworthy \cite{goals}:
\begin{itemize}
    \item Confidentiality: Information that is only meant to be viewed by certain parties must not be disclosed to other parties.
    \item Integrity: Information has to be protected against modification or forgery by malicious actors.
    \item Availability: Information has to be available according to the service specifications.
    \item Authentication: Actors have to prove their identity.
    \item Non-repudiation: Actors should not be able to claim that they did not take part in an action.
\end{itemize}
So as one can see, network security is a relatively complex topic with many different approaches, view angles and goals.

\subsection{Edge Computing}
Edge computing \cite{edgecomputing} refers to the relatively new domain to perform computations at the network edges, closer to the end user. Traditionally, the internet follows a centralized approach with servers clustered in data centers while users remain at the edges of the network. This provides some challenges to the network though, because the traffic has to be transported over long distances. This has significant impact on latency, bandwidth at central hubs, security and privacy. By moving the computational resources (e.g. servers) closer to the user at the network edge, we can reply to requests from the user with less delay, with less transportation distance (and thus cost) and with more security and privacy in mind due to decentralization. This also reduces the possible single points of failure because there is no central infrastructure anymore that could render a service unusable for all users. Edge computing has gained additional traction in recent developments due to the emergence of IoT in our everyday lifes. With a lot of data being collected by IoT devices, edge computing can be used to bundle all traffic generated by a users IoT devices closer to their origin, reducing the overall load of networks and thus their operational cost.

\section{Enabling technologies}
\subsection{Software Defined Networking (SDN)}
When building network topologies, software defined networking \cite{sdn} has emerged as one of the most valuable tools to build networks dynamically and with less cost. While traditionally specialized hardware was deployed for every use case, SDN provides a number of abstractions to build arbitrary virtual topologies on top of real-world topologies. To achieve this, software defined networking partitions the network into three major layers:
\begin{itemize}
    \item Data plane: This is the lowest layer, actually performing the work on the data to be transmitted. It is usually being realized by switches or other hardware that is used to perform work on the network traffic itself.
    \item Control plane: The control plane consists of SDN controllers that instruct the data plane components on how to handle data via a so called southbound API. The data plane components will also contact the control plane when instructions for a certain type of traffic are needed that no rules have been defined for yet. A commonly used protocol and the defacto standard for this southbound API is called OpenFlow \cite{openflow} and currently supported by a wide range of SDN capable switches. With OpenFlow, traffic is being classified into flows via flow matching tables. After traffic has been assigned to a flow, the actions that have been defined for this flow will be applied on the traffic by the data plane components. Actions include dropping traffic, queuing traffic, outputting traffic on a specific port and modifying traffic in various ways.
    \item Application plane: This plane is used to configure the SDN controllers via a northbound API. This can include end applications and users that want to manage and monitor the network.
\end{itemize}
These three layers can also been seen in figure [LINK]. % TODO: Create figure for SDN

\subsection{Network Function Virtualization (NFV)}
Closely related to SDN is the concept of network function virtualization \cite{nfv}. Network functions are components taking a specific role in a network, such as a switch which would forward or reshape traffic. Originally a lot of proprietary network functions were used to create larger networks. This resulted in a difficulty to manage the resulting networks. The proposed solution proposed for this is virtualization, so that individual network functions are decoupled from their hardware and executed in a virtual environment. The resulting network functions are called virtual network functions (VNFs) and can be orchestrated with ease to build complex topologies and integrations on a network level. Virtual network functions can thus be used as building blocks for software defined networks.

\subsection{Service Function Chaining (SFC)}
In order to interconnect our virtual network functions mentioned previously, service function chaining \cite{sfc} has emerged to connect different network functions to each other. According to Bhamare et al. \cite{sfc}, it is thus a key enabler for network function virtualization. The problem without service function chaining is, that network functions need to be linked to each other statically by providers. This provides significant effort to the network administrator to configure each connection manually in a static environment. With service function chaining, a virtualized software defined infrastructure is created connecting one network function to another, effectively forming a chain of service functions. To achieve the connections, a service function chaining architecture is used, of which multiple approaches and implementations currently exist. A common approach suggested by RFC 7665 \cite{rfc7665} is to encapsulate packets with an additional header (or additional information) that specifies the service function that the traffic should be steered towards. This header can either be added by a service function that is aware of the chain, or if the service function is not chain-aware it can be added after leaving the service function by the next network device the packet traverses to achieve easier routing of traffic. The standard also warns though (in section 5.6), that this could lead to a decrease in the maximum transmission unit (MTU), the maximum size the content of a packet may have on the network.

\subsection{Virtual Private Networks (VPN)}
A virtual private network \cite{vpn} is a virtual network overlayed on top of a real-world network providing private communication channels between their participants. With a lot of VPN approaches and implementations in existence, they can still be distinguished by classifying them per network layer. For example there are optical VPN on the physical network layer, tunnels like multi protocol label switching (MPLS, see section \ref{mpls}) on the ethernet layer and tunnels like wireguard \cite{wireguard} on the IP layer. While some only participate in routing (e.g. MPLS), others may also encrypt traffic (e.g. wireguard). Which VPN is the correct choice thus heavily depends on the use case.

One of the most prominent VPN solutions used today is wireguard \cite{wireguard}. Wireguard builds a tunnel between multiple participants (can be more than two) which then form a new virtual network. The participants can then communicate via the encrypted channels established by wireguard, which can thus traverse untrusted terrain without the fear of someone obtaining confidential information. % TODO: Maybe include source how secure wireguard is? Or maybe include it in design/validation

Another commonly used implementation is OpenVPN \cite{openvpn}, which uses a slightly different approach. While OpenVPN also encrypts traffic, it can be used to connect to a remote network securely and reach nodes on this remote network. For this, OpenVPN uses a more traditional client server approach, where the server would expose devices on his network to the client, announcing routes to the client and forwarding traffic.

\subsection{Multi Protocol Label Switching (MPLS)}
\label{mpls}
Multi protocol label switching \cite{rfc3031} was created to facilitate routing decisions within a network faster. Without MPLS each router in a network will form a routing decision based on a number of parameters from multiple packet headers by forming a longest match over addresses and comparing other header values before forwarding the packet. This deep inspection and matching of a packet can be omitted by labeling packets on the first hop. By assigning an MPLS label, encapsulating the original packet in an MPLS header, the following routers can perform their routing decision by simply investigating the label and forwarding the packet along the already well-known path. Stacking these labels is also supported, so one packet may be encapsulated multiple times. MPLS also creates the possibility to infer the class of traffic from a label by a router and thus perform decisions like precedence of a packet or discard thresholds. While this could also be performed by inspecting the packet headers closely in some cases, establishing a traffic class from a label is way less complex than a deep inspection of a packet, saving valuable computational time on core routers of a network.

\subsection{Two-phase commit protocol (2PCP)}
The two-phase commit protocol \cite{2pcp} is a protocol used to synchronize state across transactions between multiple different participants. The participant initiating a transaction is called the coordinator. The coordinator will send a change request to all participants of a transaction, which will take note of the changes and confirm whether their application is possible. This is also referred to as the voting phase. Now the coordinator will proceed to the completion phase and can observe two different outcomes. The first possibility is that every participant responded that the change is possible. If so, the coordinator will send a commit message to all participants that will then apply the changes. This concludes the transaction. When the coordinator receives one failure or no reply from one of the participants though, the coordinator will abort the transaction and send rollback messages to all participants. All participants will then discard the changes, failing the transaction. The two-phase commit protocol can not recover from a failure of the coordinator during the entire transaction or a participant during the commit phase, making it possible that an invalid state is left after a failure.

\section{Concepts}
\subsection{Quality of Service (QoS)}
% TODO: Maybe find a better base source for this chapter? --> It is hard to find a good source for such an old and basic term, thus the IP has been included for intial references of latency (delay), throughput and loss rate (high-reliability). The main qos source mentions the 4 terms below (as many other papers do).
Quality of service \cite{qos, rfc791} refers to assigning traffic to flows for which certain guarantees are to be uphold. These guarantees are usually measured in different metrics, of which the major four are outlined here:
\begin{itemize}
    \item Latency: The two-way delay for a packet travelling from flow start to finish and back.
    \item Jitter: The mean deviation of latency from the mean latency (standard deviation).
    \item Throughput: The number of bits transferable in one direction via the traffic flow in a certain time.
    \item Loss rate: The number of lost packets divided by the total amount of packets. The loss rate is especially relevant in contexts where data needs to be retransmitted when lost, because the lost data will then need to be requested again and will be delivered delayed, thus at least doubling the latency.
\end{itemize}
Securing these guarantees is an important task in network security, as violation of them could result in service level agreements (SLAs) being broken and violation of availability as one of our main goals.

To determine the flow for a certain packet, two main approaches exist \cite{serv}:
\begin{itemize}
    \item IntServ: Integrated Services \cite{rfc1633} negotiate flows beforehand with all participating network nodes. Packets are then assigned to flows based on pre-negotiated parameters. The advantage of this approach is that bandwidth and other assigned guarantees can be planned by the participating network providers in advance.
    \item DiffServ: Differentiated Services \cite{rfc2474} on the other hand match quality of service on a per packet basis, normally by using the IPv4/IPv6 differentiated services (DS) header field. The advantage of this approach is that it provides flexibility to the sender of packets who can assign priorities per packet. The disadvantage is of course that network operators can not plan ahead accurately before packets arrive and providing guarantees will be challenging.
\end{itemize}

\subsection{Network Slicing}
Network Slicing \cite{slicing} refers to partitioning part of the resources of a network to new virtual networks. Partitioned resources can include network resources, computational resources or storage resources. The result are multiple virtual networks that each have a slice of the resources of the underlying network available. In order to guarantee these resources to the owners of a slice, the slices need to be isolated from a resource perspective. The latest developments in the field are part of the 5G standard, where applications can request slices of network resources to leverage uninterrupted communication afterwards. Apart from 5G also other applications leverage this approach already, for example by partitioning network links on nodes with multiple virtual machines.

\chapter{Related Work}
\label{related_work}
\iffalse
\begin{itemize}
    \item Fundamental
    \begin{itemize}
        \item IEEE8021Q: VLAN (IEEE 802.1Q - https://standards.ieee.org/ieee/802.1Q/10323/), VXLAN (RFC 7348 - https://www.rfc-editor.org/info/rfc7348), Cisco System's Private VLAN (https://datatracker.ietf.org/doc/html/rfc5517) and other traffic segmentation methods (e.g. tunnels like GRE (RFC 2784 - https://www.rfc-editor.org/info/rfc2784)) as the original way to isolate multiple virtual networks over a real one. But: Not a real isolation due to resource sharing. --> network slicing
        \item 3gpp28.530: 3GPP TS 28.530: https://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=3273
        \item 5G1: The Isolation Concept in the 5G Network Slicing (https://ieeexplore.ieee.org/abstract/document/9200939): Concept of isolation of resource provisions in 5G
        \item 5G2: An Overview of Network Slicing for 5G (https://ieeexplore.ieee.org/abstract/document/8685766): Survey on 5G network slicing with focus on enabling technologies and the 3GPP standardization of slicing
        \item 5G3: Network Slicing in 5G: Survey and Challenges (https://ieeexplore.ieee.org/abstract/document/7926923): Yet another survey
        \item 5G4: A Comprehensive Survey on the E2E 5G Network Slicing Model (https://ieeexplore.ieee.org/abstract/document/9295415): Another survey
        \item 5GSDN1: 5G network slicing using SDN and NFV: A survey of taxonomy, architectures and future challenges (https://www.sciencedirect.com/science/article/pii/S1389128619304773): General information on 5G and slicing on SDN/NFV - maybe the best item for this paragraph
        \item 5GSDN2: Network Slicing for 5G with SDN/NFV: Concepts, Architectures, and Challenges (https://ieeexplore.ieee.org/abstract/document/7926921): Another 5G NFV survey focusing on the SDN architecture proposed by ONF (Open Networking Foundation)
    \end{itemize}
    \item Single-Domain slicing
    \begin{itemize}
        \item SD1: Network Slicing Based 5G and Future Mobile Networks: Mobility, Resource Management, and Challenges (https://ieeexplore.ieee.org/abstract/document/8004168): Slicing in 5G networks and handover of slices to other networks (focus on individual network supporting these characteristics).
        \item SD2: Survey on Network Slicing for Internet of Things Realization in 5G Networks (https://ieeexplore.ieee.org/abstract/document/9382385): Survey for IoT devices in 5G networks - discuss applications of network slicing for IoT
        \item SD3: A Resource Allocation Framework for Network Slicing (https://ieeexplore.ieee.org/abstract/document/8486303): Discuss resource allocation strategies for network slices combating inefficient resource allocations and present a new framework to perform better allocations.
    \end{itemize}
    \item Multi-Domain slicing
    \begin{itemize}
        \item MD1: Towards 5G Network Slicing over Multiple-Domains (https://search.ieice.org/bin/summary.php?id=e100-b%5F11%5F1992): Create a network slicing framework over multiple domains in the 5G context. No focus on QoS guarantees or validation
        \item MD2: On Multi-Domain Network Slicing Orchestration Architecture and Federated Resource Control (https://ieeexplore.ieee.org/abstract/document/8758980): Focusses on resource slicing (also storage, computing, and more) in the 5G context. No focus on QoS guarantees or validation
        \item MD3: SliceNet: End-to-End Cognitive Network Slicing and Slice Management Framework in Virtualised Multi-Domain, Multi-Tenant 5G Networks (https://ieeexplore.ieee.org/abstract/document/8436800): A project aiming to provide a slicing implementation for 5G networks
        \item MD4: Cross-Domain Network Slicing for Industrial Applications (https://ieeexplore.ieee.org/abstract/document/8443241): Cross-domain QoS slicing for a wind turbine network. With a central QoS orchestrator managing resource allocations.
        \item MD5: Multi-Domain Network Slicing With Latency Equalization (https://ieeexplore.ieee.org/abstract/document/9136770): Explore means of routing packets across different paths according to their delay to achieve network slicing with less packets arriving late when latency is constrained (latency limits, better utilization of resources due to multiple paths)
    \end{itemize}
    \item Security in network slicing
    \begin{itemize}
        \item SE1: Network slicing security: Challenges and directions (https://onlinelibrary.wiley.com/doi/full/10.1002/itl2.125): Isolation as a core requirement, alongside formal security requirements for network slicing (CIA)
        %\item ML-Based 5G Network Slicing Security: A Comprehensive Survey (https://www.mdpi.com/1999-5903/14/4/116): Use a ML-based approach to design, implement and secure slices. (Not sure if this should make it in the text - seems to be offtopic even though it partially investigates security with ML)
        \item SE2: 5G Network Slicing: A Security Overview (https://uis.brage.unit.no/uis-xmlui/handle/11250/2682454): Discusses new security challenges (life-cycle security, intra-slice security, and inter-slice security) and privacy concerns (exposing information by API or inter-slice communications) for network slicing -> use these terms
        \item SE3: Network Slicing Security Controls and Assurance for Verticals (https://www.mdpi.com/2079-9292/11/2/222): Propose different security controls that enforce security policies in specific areas of a network, which can thus be used in network slicing to secure a slice with otherwise weak isolation.
        \item SE4: Securing cross-domain links using end-to-end network slicing (N. Fuhrberg): Investigating network slicing security in a SDN network slicing context. Propose distributed architecture and validate in a local setting.
    \end{itemize}
    \item Our contribution: Extend and redesign the topology proposed by N. Fuhrberg to a fully distributed setting with distributed trust among network coordinators, attempt to combat previous drawbacks (slice QoS failure with large traffic ingress on switches => full slice isolation), provide a distributed implementation that is able to integrate real-world hardware forming a mesh of networks/autonomous systems and perform validation in both a local test case for reference and a distributed test case. (=> Requirement list)
\end{itemize}
\fi
When thinking about partitioning or slicing a part of a network, traditionally VLANs (virtual local area network) \cite{IEEE8021Q} or VXLANs (virtual extended local area network) \cite{rfc7348} come to mind. The goal of VLAN or VXLAN is to annotate packets with an id to distinguish certain traffic from other traffic. As the name suggests a virtual LAN will act as an emulated LAN on top of a real-world LAN, partitioning a switch or other network hardware. This is achieved by maintaining different routing tables based on the specific VLAN, enabling network administrators to specify where packets from a certain VLAN may or may not go. VLANs can be distinguished by tagged and untagged VLANs \cite[25.2]{IEEE8021Q}. Originally only untagged (also called port based) VLANs were available, where a specific switch port is assigned to a specific VLAN, binding this port statically \cite[25.3]{IEEE8021Q}. It was thus a full hardware separation but on the other hand also quite inflexible with the static port binding. To combat this issue, tagged VLANs were developed. Tagged VLANs use information stored within the network packet headers to assign a VLAN id to each packet \cite{IEEE8021Q}. While this creates a small overhead on the network, it allows to share one port between multiple VLANs. For example, the IEEE 802.1 Q standard defines a commonly used VLAN solution that encapsulates the original packet in a VLAN header, including a 12-bit VLAN id. As networks evolved however, more than 4096 VLAN ids were needed and other means of tagged VLANs were implemented, such as Cisco Systems' Private VLAN (RFC 5517) \cite{rfc5517} or VXLAN (RFC 7348). VXLAN for example uses 24-bit ids and can thus provide a way bigger value space than the header of IEEE 802.1 Q.

Another way to achieve this kind of functionality is by using tunnels through a certain part of the network. A common approach to use are for example GRE tunnels \cite{rfc2784}, which enable the network administrator to send arbitrary network protocols over another arbitrary protocol, differentiated by an optional key found in the GRE packet header.

In the modern context of 5G networks, the term slicing has been established to provide a slice of network, computational or storage resources from a certain network that are guaranteed to be available to an application after their reservation \cite{5G1,5G2,5G3,5G4} and that isolate components resource wise. Slicing has the advantage over the previously mentioned VLANs, that slices can also provide resource guarantees, while in a traditional VLAN setup all VLANs share the same resource pool (without any additional configuration). Furthermore 5G network slices can be requested live by users and applications following for example the 3GPP 5G network slicing specification (TS 28.530) [CITATION NEEDED] that is currently still under development, while VLANs are set up by network administrators in advance and do not dynamically change.

In general there are many approaches that focus on slicing on a single, local administrative domain (a network managed by one system administrator/team) \cite{SD1,SD2,SD3}. Examples for this are the resource allocation framework proposed by Mathieu Leconte et al. \cite{SD3} focussing on the resource management of 5G slicing on local domains, the mobile handover strategies discussed by Haijun Zhang et al. \cite{SD1} for future mobile networks and slicing of local domains in the context of IoT \cite{SD2}.

Furthermore there are also projects to create slices over multiple domains \cite{MD1,MD2,MD3,MD4,MD5}, such as the network slicing framework proposed by Ibrahim Afolabi et al. \cite{MD1} building around a "Dynamic Adaption Stack" offering services such as provisioning, accounting and more. Another such framework is SliceNet \cite{MD3}, which aims to provide an initial implementation of slicing in 5G networks and is a project of the EU 5G Infrastructure Public Private Partnership (5G PPP). Others are investigating the role of QoS in cross-domain slicing, such as Vasileios Theodorou et al. \cite{MD4} in their network of wind turbines in Denmark, while Ivana Kovacevic et al. \cite{MD5} aim to route slice traffic among multiple routes based on their estimated time of arrival to provide a network with more stable latency. These solutions often use NFV to manage, orchestrate and deploy the slicing network, as NFV provides excellent flexibility to build network topologies in a SDN context \cite{5GSDN1,5GSDN2}.

So as one can see, there are a lot of topics in this field that are currently being investigated by researchers and industry all over the world due to its key role in future communication systems.  And while slicing is an amazing opportunity to face many application demands and security concerns with modern IoT devices by isolating them from other network participants, there are also security concerns of attackers jeopardizing network slicing in such a network, resulting in QoS decrease, outages and spying attempts on possibly all applications within \cite{SE1}. To combat these threats, Vitor A. Cunha et al. \cite{SE1} have formerly described the well estabilished protection goals of confidentiality, availability, integrity, authentication and authorization for slicing applications. Their results are as follows:
\begin{itemize}
    \item Confidentiality: The slice contents must not be disclosed outside of the end devices and authorized devices participating in the slice.
    \item Availability: The system must perform correctly under the specific service level agreement and all VNFs within a slice must be available at all times. There is however no guarantee that new slices may always be able to be established when resource availability does not permit it.
    \item Integrity: There may be no side channels to slices (all data must go through the slice and not through other interfaces) and all participants of a slice may not be under influence of attackers that could tamper with data or replace functionality in an undetected way.
    \item Authentication: All human and device participants must be authenticated at all time to perform actions of any kind on slices or the underlying infrastructure.
    \item Authorization: To perform actions on specific slices or infrastructure, the specific user must be allowed to do so, for example by having ownership of the slice.
\end{itemize}
Ruxandra Olimid et. al \cite{SE2} try a different approach of classifying threats as either life-cycle, inter-slice or intra-slice security concerns. Life-cycle threats are threats to the bootstrapping or removal of slices, threatening their existence. Inter-slice threats are threats like side-channel attacks or information disclosure, that take place when two different isolated parties have means to communicate with each other or obtain information about one another without being part of the same slice. Information disclosure can also happen when one participant is part of multiple slices and shares information that was only meant for one slice. The intra-slice threats are then threats within the slice itself, such as a malicious participant.
To protect slicing implementations against these threats and to reach protection goals, Tomasz Wichary et al. \cite{SE3} suggested different security controls to isolate certain parts of networks that are otherwise only weakly isolated. They reach their goals by employing security policies to certain parts of the slicing network to achieve good resource isolation on multiple layers while utilizing vendor specific and vendor independent tools. Niklas Fuhrberg et al. \cite{SE4} investigated QoS degradation in their NFV based slicing topology that spanned multiple virtual domains with a single administrative entity called ESMF (edge slice management function). They validated their topology in a local testbed using Mininet \cite{mininet} (a network emulator) reaching the result that an adversary attacking a switch from multiple angles can still overload the switch and reach considerate QoS degradation in their example of controlling a remote robot.

In this thesis we wish to build a topology with a distributed control plane and management to create a network slicing testbed based on NFV and SFC. We will attempt to redesign the topology by Fuhrberg et al. to reach full network isolation of slices from one another, as well as distributed trust among the different participating administrative domains.
To achieve these goals, we impose the following requirements:

\begin{description}[style=multiline, labelwidth=0.7cm]
    \item[\namedlabel{R1}{R1}] We want our slices to be fully isolated concerning network resources. Adversaries (see section \ref{adversaries}) should not be able to violate our protection goals (see section \ref{protection_goals}).
    \item[\namedlabel{R2}{R2}] We want to build a slicing network that spans multiple domains that are administered by multiple parties. We require this to be able to establish slicing communication over participating third party networks such as the DFN (German Research Network) without requiring to trust the 3rd-party networks apart from respecting their SLA (service level agreement). This includes a fully distributed control and data plane.
    \item[\namedlabel{R3}{R3}] We want our solution to be able to run on real-world networks to be able to obtain real-world results apart from small local testbenches. This is also important to be able to evaluate our QoS requirements on specialized hardware like real-world switches that can leverage hardware acceleration.
    \item[\namedlabel{R4}{R4}] We want to be able to create slices from an arbitrary amount of networks to an arbitrary amount of other networks. While one slice must only connect two networks, other networks should be reachable as well, as most modern applications wish to reach out to multiple parties in multiple destinations.
\end{description}

Question 1: Are the requirements good like this? I provide requirements here with an additional reference to our attackers and protection goals so that we can a) use R2, R3 and R4 to distinguish our new solution from Niklas' solution passively (no active comparison) and b) use R1 to validate our protection goals later. With this we can later validate our solution using the requirement list with embedded protection goals, which would be a good solution in my opinion (to not validate everything separately). We will of course argue that R2-4 are by design. Are any requirements missing in your opinion?

Question 2: Is Niklas' thesis appropriately mentioned? I stated our solution as a redesign of his, because even though all the VNFs are completely redesigned and reimplemented (sometimes even in their base concepts of operation, like by which means things are communicated and deployed), the basic concept of a chain of ESMF->DSMF is almost the same. Our components are different of course (for example the role of the ESMF for other networks, the synchronization, the ryu controller as way to deploy the flows, and also the isolation itself). Should Niklas' thesis be mentioned later on? I do not currently think that comparing the works more than above is needed, as I already mentioned a core difference above (the role of the ESMF ["with a single administrative entity called ESMF"]). I would thus like to continue with the upcoming chapters without further referencing it. Is that a good approach or would it be ideal to further mention it?

Question 3: Is the presented related work relevant in your opinion or should I explore a certain field more?

\chapter{Methodology}
\iffalse
\begin{itemize}
    \item Requirement validation as base methodology
    \item Test environment (Discussion Mininet vs Distrinet vs our solution)
    \item Protection goals (including metrics like bandwidth and latency)
    \begin{itemize}
        \item Questions that can be validated in chapter “Validation” => Protection goal list
    \end{itemize}
    \item Attackers
    \item Deployments
    \begin{itemize}
        \item Full local deployment
        \item Minimal distributed deployment (2 Hosts, 1 real-world SDN Switch)
    \end{itemize}
\end{itemize}
\fi
To achieve our goal we will use requirement validation. Initially we defined our requirements as stated in the end of chapter \ref{related_work}. In this chapter we will thus choose an accurate environment for our experiments, define a network model, our protection goals and attackers, before finally stating the scenarios we wish to validate and our measurements we wish to obtain on them.

\section{Test environment}
As a test environment we want to use a network emulator to be able to easily bootstrap our solution. For this, multiple emulators are available, including mininet \cite{mininet}, distrinet \cite{distrinet1, distrinet2}, maxinet \cite{maxinet}, ComNetsEmu \cite{comnetsemu} or our own testbed solution \cite{owntb}.
Mininet (and ComNetsEmu as a fork of mininet) emulate network topologies on a single machine, but do not scale to multiple machines. As we want to test in a distributed setting, they are sadly out of the equation. Distrinet and maxinet would both allow us to scale mininet topologies to multiple machines. As we want to be able to deploy our topologies to real-world devices in the future though and integrate real-world hardware (requirement R3), we would need to invest additional effort in deploying to real-world hardware in the future when using them. Our own testbed solution mitigates these issues by supporting multiple modes of deployment including support for real-world hardware that can easily be extended. We will thus opt to use our own testbed solution to evaluate our solution.

\section{Network model}
In the context of our networks, we will establish two different kinds of networks.
\paragraph{Edge networks}
are the origin and target of one specific network slice. Each edge network is partially trusted by us, because we or another trusted party operate the core infrastructure. We only expect threats from adversaries outside of our switches or slicing architecture, for example as a host established within our edge network.
\paragraph{Black networks}
lie between the edge networks and are operating under a service level agreement (SLA). There may be any number of black networks between two edges, including none. A black network acts as a transit network to us and is semi-trusted because the infrastructure is not operated by us. We do trust that the black network will act according to protocol, but it might be interested in breaking confidentiality as an honest-but-curious attacker. As with our edge networks, we expect attackers to be established outside of the switching and slicing architecture, apart from potential eavesdropping by the transport infrastructure of the black network.

Please note that that one specific network may play different roles for different network slices. One slice may pass through a black network that is also the origin (and thus edge network) of another slice.

% TODO: Add figure

\section{Protection Goals}
\label{protection_goals}
The next question we posed was what we actually want to protect from our attackers. In general we want to protect the communication from one host to another and provide certain guarantees to the hosts. These guarantees include bandwidth, latency, jitter, loss rate and of course availability. Furthermore we want to protect traffic from modification or information disclosure in networks between our edge networks. We do not require this protection on our edge networks, since we trust our self-managed infrastructure to a certain degree. Our protection goals are thus:
\begin{description}[style=multiline, labelwidth=0.7cm]
    \item[\namedlabel{P1}{P1}] Traffic needs to be protected from modification or disclosure outside of the edge networks.
    \item[\namedlabel{P2}{P2}] Slices need to be available for communication and deliver packets to the recipient at all times during their lifespan.
    \item[\namedlabel{P3}{P3}] Slices need to provide their guaranteed network resources with their specified bandwidth, latency, jitter and loss rate.
\end{description}

\section{Attackers}
\label{adversaries}
As previously mentioned, Ruxandra Olimid et. al \cite{SE2} classified threats to network slicing as either life-cycle threats, inter-slice threats or intra-slice threats. We will not consider intra-slice threats, as intra-slice threats do not target our slicing design or implementation but rather the components within the created slice, which is out of scope for this thesis. We will thus focus more on life-cycle and inter-slice threats.

For inter-slice threats we will create an attacker utilizing a lot of resources within another slice to overload the network and potentially create artifacts in our slice that should be protected. We do not consider side-channel attacks on our slicing implementation to test the isolation between slices as it heavily depends on the used components while we will try to support a variety of components (e.g. the implementation of queues in the linux kernel vs a hardware switch).

For life-cycle threats we will introduce two attackers, one spamming our application plane with arbitrary requests and one spamming our slice coordinators with valid requests. We hope to achieve denial of service for new slice registrations with the first attacker and an overload of network resources by the second attacker.

As a last attacker we will consider an attacker attempting to eavesdrop within one of the black networks between our two edge networks. Eavesdroppers are not expected on our edge networks, as we trust our local environment.

We do not consider active in-path attackers, as they could disrupt communication at any time. If resilience against these kinds of attacks is needed, the solution would need to be extended to include multiple paths. This is however out of scope for this thesis. Apart from all components and links used by the network slice, in-path attackers contain our entire application layer, as any component of the application layer could instruct other components to disrupt the connection or disrupt the connection themselves.

Our attacker definitions are thus as follows:
\begin{description}[style=multiline, labelwidth=0.7cm]
    \item[\namedlabel{A1}{A1}] Overloads the network by sending a lot of traffic through another slice that has shared components and network links with our slice that should be protected.
    \item[\namedlabel{A2}{A2}] Spams invalid slice requests on the application plane attempting to disrupt the creation of new slices.
    \item[\namedlabel{A3}{A3}] Spams valid authenticated slice requests on the application plane attempting to overload the network by capacity or frequent slice creation and removal.
    \item[\namedlabel{A4}{A4}] Attempts to eavesdrop within one of the networks between our edge networks.
\end{description}
%TODO: Add figure without our specific architecture showing our attackers

\section{Scenarios}
We will test three scenarios in total. The first scenario will provide a base case for our two other slicing-enabled scenarios, of which one will be local and the other distributed.

The base solution will consist of two simulated hosts, two attackers and two switches. Each switch is connected to one of the hosts, one of the attackers and to the other switch. The attackers share the link between the switches with the normal host. The attacker \ref{A1} will then become active and attempt to disrupt the communication between the hosts. Furthermore we will employ attacker \ref{A4} to eavesdrop traffic between the switches. \ref{A2} and \ref{A3} do not apply since there is no slicing infrastructure.

For our first slicing scenario we will deploy our slicing solution emulating 3 domains with two edge networks and one black (semi-trusted) network between them. We will place one attacker each in the edges to spam a slice between them as attacker \ref{A1}. We will deploy \ref{A4} on a link in the black network and deploy \ref{A2} and \ref{A3} to the application layer.

As the last scenario we will deploy the previous scenario to three different servers that are connected via 10G links to an Aruba 2930F switch. Each server will contain one entire simulated domain. We hope that by this scenario we can observe some real-world performance characteristics when utilizing real links in our test environment.

For each scenario we will try to establish two network slices in total. As an example, we want to control a robot on the other side by receiving a video stream and maintaining a bidirectional control and feedback stream. One slice will thus be unidirectional and streaming media content. We will allocate 8Mbit/s to this slice, because this encompasses streaming of HD video (according to the FCC \cite{fcc}). We require a relatively small loss rate for this to not skip frames on the video stream, but loosing single packets and skipping a frame will not be too much of an issue. Jitter may occur as we can buffer our video stream data for short amounts of time, however we want our latency to be low so our frames appear in almost real time. For the bidirectional control and feedback slice, we need far less bandwidth. The loss rate needs to be lower than with the video stream to be in control at all times. Also we require a low latency and low jitter to be able to react in real time and without any jittering movements. We will thus apply the resource guarantees in table \ref{table:1} for our experiments.

\begin{table}[ht]
    \centering
    \begin{tabular}{ |c|c|c| }
    \hline
    Metric & Media & Control \\
    \hline
         Bandwidth & 8Mbit/s & 100Kbit/s \\
         Latency   & 5ms     & 3ms      \\
         Jitter    & \textless 0.5ms  & \textless 0.3ms   \\
         Loss rate & \textless 0.01\% & \textless 0.001\% \\
    \hline
    \end{tabular}
    \caption{The guarantees we wish to meet with our slices}
    \label{table:1}
\end{table}

This example including the bandwidth requirements is taken from Fuhrberg et al. \cite{SE4} in order to be able to compare their solution against our redesigned solution. The values for latency, jitter and loss rate have been altered to reflect our goals and generally provide more strict requirements.

% TODO: Add figures for each scenario (without topology details)

\section{Measurements}
For each scenario and each attacker (apart from \ref{A4}), we will investigate the availability of our slice and measure our available bandwidth, loss rate, latency and jitter while sending the amount of traffic we reserved. We will compare our results to the values that we requested in the individual slice.

For the eavesdropping attacker \ref{A4} we will listen on the link between the switches for the non-edgeslicing scenario and on a link in the black network for the edge-slicing scenarios.

\chapter{Design}
\iffalse
\begin{itemize}
    \item Components
    \begin{itemize}
        \item Overview
        \item ESMF \& CTMF
        \item DSMF \& DTMF
        \item Controller
        \item SDN Switch
        \item VPN Gateway
    \end{itemize}
    \item Concepts
    \begin{itemize}
        \item Distributed trust and authority
        \item State synchronization (2PCP)
        \item Strict separation of SDN layers
    \end{itemize}
\end{itemize}
\fi
This chapter is centered around the components and concepts embodied in our network slicing architecture. We will first give an overview over our components and then present some concepts that will need to be implemented by our implementation.

\section{Components}
In order to present our components to achieve a network slicing architecture, we will present them grouped by SDN layer. We will begin by presenting the data plane, followed by the control plane and conclude with the application plane. In figure [LINK] you can already see the final result of our suggested topology, where the links that are used by the slice are marked green. Please note that other network architectures are possible as well and this is only an example topology. The focus is on the application and control plane components per network domain.

\subsection{Data plane}
The job of the data plane is to transport traffic, so in our use case it will need to achieve the network resource isolation we require from our slices (protection goal \hyperref[P3]{P3}). To configure this isolation we need a way to assign traffic to QoS flows that span from one edge to another, traversing all required black networks in the process. Furthermore we need to limit third party traffic so it may not impede our resource allocations. In order to perform easier routing decisions along our path, we wish to label traffic traversing a network slice according to the MPLS scheme. As a last data plane measure we require traffic to be encrypted while traversing the black networks (protection goal \hyperref[P1]{P1}).

To deploy the QoS flows and secure them against third party traffic (protection goal \hyperref[P3]{P3}), we will need to make use of SDN switches. The switches will forward the packets from source to destination, while the first switch will tag the packets with an MPLS label to facilitate easier routing and perform authentication of slice traffic along the entire path, the last switch will finally remove the MPLS label again. All switches will discard MPLS traffic from different ports than expected and drop packets with MPLS labels not expected to be found on a port. This way we can prevent third party traffic entering our slice. The switches also have to limit traffic from other participants to guarantee the slice resources, which can be realised by creating a "default slice" for all non-slice traffic on the network. This can lead to underprovisioning of network resources however. The default slice should be shrunk when new slices are created to accommodate the new slices or have a relatively small size to not be able to disturb our slices. The slice resources can be guaranteed by setting up queues for all slices and the default slice to limit the overall possible outgoing traffic per port. For ingress traffic on ports, port ingress limits should be set up so that the switch may not be overloaded by the sheer amount of traffic from all sides.

For the encryption along the black networks we will use VPN gateways that encrypt traffic (protection goal \hyperref[P1]{P1}). The VPN gateways will only ever see traffic from slices and should be shielded from all other traffic to limit the surface of attack. To connect to a remote end, VPN gateways will use tunnels that need to be cryptographically secure to not disclose information. In order to limit the effect of information disclosure by the sheer existence of a slice through the black networks, we will bundle multiple slices through one single tunnel. Packets from the tunnel will be tagged with another tunnel MPLS label by the first switch and the label will be removed again by the final tunnel switch due to the same reasons as with the original slice packets. A packet is assigned to a specific tunnel by examining the slice id in the MPLS label from the first slice switch. When a packet is traversing the tunnel, the unified guarantees for the individual slices should apply, meaning a sum of the individual bandwidths and the lowest values for latency, jitter and loss.

% TODO - Figure for only the data plane components?

\subsection{Control plane}
The control plane should mainly support deploying our rules to our devices. Creating the flows is supported by using OpenFlow through a standard SDN controller. For our queues and ingress limits we will need a separate service realizing them on the switches though, as these features are not currently supported by OpenFlow. We suggest implementing them via a service running on the SDN switches. For the VPN gateways we require another service running on the specialized VPN gateway hosts allowing us to register, resize and delete tunnels, as well as assigning slices to tunnels.

% TODO - Figure for only the control plane components?

\subsection{Application plane}
The application plane will then care about defining the rules that should be deployed. In order to instruct the control plane, we will create a infrastructure coordinator per domain that will carry out all infrastructure tasks. This service that we will call a domain slice management function (DSMF) will know about the entire topology and will have the routing information to other domains. It will set up domains and tunnels on the local infrastructure if requested and specify upfront whether resources can be guaranteed or not. This service thus follows an IntServ pattern to realize network slices. Apart from this infrastructure service we will need to establish a domain coordination service, called an edge slice management function (ESMF), coordinating the deployment of slices and tunnels across multiple domains. Apart from the coordination role it should also be the main endpoint for participants from the local domain to request slices through the network. By contacting other domains and the local infrastructure service the coordination service can evaluate whether a slice request from a participant is currently possible or not. For isolation purposes, only the coordination service of a domain (ESMF) will be allowed to contact the infrastructure service (DSMF) of the same domain. The ESMFs will only talk between each other and with tenants of their own domain.

While ESMF and DSMF allow the creation of slices and tunnels on their respective domain, versions of them also exist with reduced functionality for black networks that do not wish to offer their tenants slice support. The ESMF will be replaced with a core tunnel management function (CTMF) and the DSMF will be replaced with a domain tunnel management function (DTMF). A CTMF will never initiate a new tunnel but rather receive tunnel requests from coordinating ESMFs. Also a CTMF will never accept slice requests from tenants of their domain. They will thus only talk to an ESMF of another domain to coordinate new tunnels or with their own DTMF to deploy tunnels to their infrastructure and to check for resource availability. A CTMF may only talk to a DTMF and an ESMF may only talk to a DSMF, depending on the network role. CTMF and DTMF may only be deployed on black networks that are exclusively black networks, requiring their network domain to never be the beginning nor the end of a slice.

% TODO - Figure for only the application plane components?

\section{Concepts}
After we presented our components we now want to mention our concepts behind certain design decisions, beginning with our concept of distributed trust and authority, our state synchronization and the strict separation of SDN layers.

\subsection{Distributed trust and authority}
Distributed trust and authority is one of our core requirements (see \hyperref[R2]{requirement R2}). While wanting to lend resources to participants of our and other networks participating in our slicing architecture and guaranteeing those resources to them, we do not want others taking deployment or infrastructure decisions for our local domain. This is why we separated the coordination across all domains and only expose the coordinators to the other domains. This way another domain can ask us to allocate resources for a new slice but we may deny the creation at any point in time. Still other domains can request slices and tunnels this way without having direct access or knowledge over our infrastructure.

\subsection{State synchronization}
In order to be able to coordinate slices and tunnels across multiple domains we need to synchronize a global state across them. Without this synchronization slices could potentially be deployed only partially, violating our requirement of the basic availability of a slice (see requirement \hyperref[R1]{R1} and protection goal \hyperref[P2]{P2}) when traffic can not pass all domains along the slice. Our implementation will thus need to synchronize a global state for each slice between the coordinators.

\subsection{Strict separation of SDN layers}
In order to reach our goal to be relatively hardware independent (requirement \hyperref[R3]{R3}) we want to clearly structure our services according to our SDN layers. Of course this may not always be possible because for example our switch queue and ingress limit service will be vendor specific due to no unified API being available at this point to manage these characteristics. For all other services, the design as been separated according to the SDN layers to be able to swap out different components of the SDN environment with ease. For example to use a switch of a different vendor, only the switch queue and ingress limit service will need to be reimplemented for this vendor while the rest of the components can remain in use. This includes the integration of hardware switches or servers, enabling our topology to be executed outside of testbench scenarios.

\chapter{Implementation}
\begin{itemize}
    \item Specification
    \begin{itemize}
        \item OpenAPI REST specifications
        \item Communication
        \begin{itemize}
            \item Slice creation
            \item Slice removal
        \end{itemize}
    \end{itemize}
    \item Components
    \begin{itemize}
        \item Implemented in python using auto-generated code by OpenAPI
        \item Interconnected via testbed + real-world hardware integration
        \item TODO: What is missing from design to reproduce implementation?
    \end{itemize}
    \item Concepts
    \begin{itemize}
        \item Same as in design - specify their implementation
    \end{itemize}
    \item Attackers
    \begin{itemize}
        \item Specify how the individual attackers from the methodology were implemented
    \end{itemize}
\end{itemize}

\chapter{Validation} % Security and Performance analysis?
\begin{itemize}
    \item Expectations
    \item Base-line topology (setup without protections)
    \item Measurements and Results
    \begin{itemize}
        \item Test Scenario/Attacker N
        \begin{itemize}
            \item Validate against all protection goals X deployments (base-line, local and distributed)
        \end{itemize}
    \end{itemize}
\end{itemize}

\chapter{Conclusion}
\begin{itemize}
    \item Summary
    \item Limitations
    \item Future work
\end{itemize}

\listoffigures
\listoftables

\printbibliography

\end{document}
